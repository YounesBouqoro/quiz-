<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Java MC-Quiz â€“ 12 aus 500 (Probeklausur-Stil, validiert)</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;margin:0;padding:24px;background:#f6f7fb;color:#0f172a}
    .app{max-width:980px;margin:0 auto;background:#fff;border-radius:16px;box-shadow:0 12px 30px rgba(2,8,23,.08);overflow:hidden}
    header{padding:18px 20px;background:linear-gradient(135deg,#0ea5e9,#6366f1);color:#fff;display:flex;align-items:center;justify-content:space-between;gap:12px}
    header h1{font-size:16px;margin:0;font-weight:900}
    header .meta{font-size:13px;opacity:.95}
    main{padding:20px}
    .row{display:flex;flex-wrap:wrap;gap:10px;align-items:center;justify-content:space-between;margin-bottom:16px}
    .pill{display:inline-flex;align-items:center;gap:8px;background:#eef2ff;color:#3730a3;border:1px solid #e0e7ff;padding:8px 12px;border-radius:999px;font-size:13px;font-weight:800}
    .progress{flex:1;min-width:220px;height:10px;background:#e5e7eb;border-radius:999px;overflow:hidden}
    .progress>div{height:100%;width:0%;background:#22c55e;transition:width .25s ease}
    .card{border:1px solid #e5e7eb;border-radius:14px;padding:16px;background:#fff}
    .q-title{margin:0 0 10px 0;font-size:16px;font-weight:900}
    pre{background:#0b1220;color:#e5e7eb;padding:12px 14px;border-radius:12px;overflow:auto;margin:10px 0 14px 0;font-size:13px;line-height:1.35}
    .options{display:grid;gap:10px;margin-top:8px}
    .opt{border:1px solid #e5e7eb;border-radius:12px;padding:10px 12px;display:flex;gap:10px;align-items:flex-start;cursor:pointer;user-select:none;transition:border-color .15s ease,background .15s ease}
    .opt:hover{border-color:#cbd5e1;background:#f8fafc}
    .opt input{margin-top:2px}
    .opt.correct{border-color:#16a34a;background:#f0fdf4}
    .opt.wrong{border-color:#dc2626;background:#fef2f2}
    .feedback{margin-top:14px;padding:12px 12px;border-radius:12px;border:1px solid #e5e7eb;background:#f8fafc;display:none}
    .feedback.ok{border-color:#16a34a;background:#f0fdf4}
    .feedback.no{border-color:#dc2626;background:#fef2f2}
    .btnbar{display:flex;gap:10px;margin-top:14px;flex-wrap:wrap}
    button{border:0;border-radius:12px;padding:10px 14px;font-weight:900;cursor:pointer;background:#111827;color:#fff}
    button.secondary{background:#e5e7eb;color:#111827}
    button:disabled{opacity:.55;cursor:not-allowed}
    .result{display:none;border:1px solid #e5e7eb;border-radius:14px;padding:16px;background:#fff}
    .result h2{margin:0 0 8px 0;font-size:18px}
    .review{margin-top:12px;display:grid;gap:10px}
    .review .item{border:1px solid #e5e7eb;border-radius:12px;padding:12px;background:#f8fafc}
    .small{font-size:13px;color:#334155}
    .danger{border:1px solid #fecaca;background:#fef2f2;color:#7f1d1d;padding:10px 12px;border-radius:12px;margin-bottom:14px;display:none}
  </style>
</head>
<body>
<div class="app">
  <header>
    <div>
      <h1>Java MC-Quiz â€“ 12 aus 500 (Probeklausur-Stil)</h1>
      <div class="meta">Random 12 Fragen pro Durchlauf â€¢ Antworten berechnet â€¢ Self-Check beim Start</div>
    </div>
    <div class="meta"><b>Pool:</b> <span id="poolSize">0</span> â€¢ <b>Quiz:</b> 12</div>
  </header>

  <main>
    <div id="fatal" class="danger"></div>

    <div class="row">
      <div class="pill">Frage: <span id="qIndex">1</span>/<span id="qTotal">12</span></div>
      <div class="pill">Punkte: <span id="score">0</span></div>
      <div class="progress" aria-label="Fortschritt"><div id="bar"></div></div>
    </div>

    <section id="quizCard" class="card" aria-live="polite">
      <p id="qTitle" class="q-title"></p>
      <pre id="qCode" style="display:none"></pre>

      <div id="options" class="options"></div>

      <div id="feedback" class="feedback">
        <div id="fbTitle" style="font-weight:900;margin-bottom:6px;"></div>
        <div id="fbText" class="small"></div>
      </div>

      <div class="btnbar">
        <button id="checkBtn" disabled>Antwort prÃ¼fen</button>
        <button id="nextBtn" disabled>Weiter</button>
        <button id="restartBtn" class="secondary">Neues 12er-Quiz</button>
      </div>
    </section>

    <section id="result" class="result">
      <h2>Ergebnis</h2>
      <p class="small" id="resultText"></p>
      <div class="btnbar">
        <button id="restartBtn2">Nochmal (neu ziehen)</button>
        <button id="reviewOnlyWrongBtn" class="secondary">Nur falsche wiederholen</button>
      </div>
      <div class="review" id="review"></div>
    </section>
  </main>
</div>

<script>
/** ---------- Utils ---------- **/
const el = (id) => document.getElementById(id);

function shuffle(arr) {
  const a = arr.slice();
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

function sampleUnique(arr, n) {
  if (n >= arr.length) return shuffle(arr);
  const idxs = new Set();
  while (idxs.size < n) idxs.add(Math.floor(Math.random() * arr.length));
  return Array.from(idxs).map(i => arr[i]);
}

function escapeHtml(str) {
  return String(str)
    .replaceAll("&", "&amp;")
    .replaceAll("<", "&lt;")
    .replaceAll(">", "&gt;")
    .replaceAll('"', "&quot;")
    .replaceAll("'", "&#039;");
}

function uniq(arr) {
  return Array.from(new Set(arr));
}

function assert(condition, msg) {
  if (!condition) throw new Error(msg);
}

/** ---------- Question Model ---------- **/
/**
 * We store "canonical" questions with correctIndex.
 * On each render we shuffle options and compute shuffledCorrectIndex.
 */
function withShuffledOptions(q) {
  const pairs = q.options.map((text, i) => ({ text, i }));
  const shuffledPairs = shuffle(pairs);
  const shuffledOptions = shuffledPairs.map(p => p.text);
  const shuffledCorrectIndex = shuffledPairs.findIndex(p => p.i === q.correctIndex);
  return { ...q, shuffledOptions, shuffledCorrectIndex };
}

/** ---------- Generators (safe, computed) ---------- **/
let nextId = 1;
function mkQ({title, code=null, options, correctIndex, explain}) {
  return { id: nextId++, title, code, options, correctIndex, explain };
}

function mkSingleCorrectOptions(correctText, wrongTexts) {
  const options = uniq([correctText, ...wrongTexts]).slice(0,4);
  // If uniqueness reduced options <4, pad safely
  while (options.length < 4) options.push(`(Ablenkung ${options.length})`);
  const correctIndex = options.indexOf(correctText);
  return { options, correctIndex };
}

/** Topic: Tools */
function genTools(n) {
  const qs = [];
  const base = [
    {q:"Welches Programm Ã¼bersetzt Java-Quellcode in Bytecode?", a:"Compiler", wrong:["Debugger","Profiler","Interpreter"],
      ex:"Compiler (javac) erzeugt .class-Bytecode aus .java."},
    {q:"Welches Programm dient der Fehlersuche zur Laufzeit (Breakpoints, Step-Through)?", a:"Debugger", wrong:["Compiler","Profiler","Interpreter"],
      ex:"Debugger: Schritt-fÃ¼r-Schritt und Variablen beobachten."},
    {q:"Welches Programm misst primÃ¤r Performance/Hotspots (CPU/Memory)?", a:"Profiler", wrong:["Debugger","Compiler","Interpreter"],
      ex:"Profiler analysiert Performance/Hotspots."},
    {q:"Welche Aussage zu Java ist korrekt?", a:"Java-Programme sind mit JVM plattformunabhÃ¤ngig", wrong:["Java lÃ¤uft nur unter Windows","Java ist rein interpretiert","Java benÃ¶tigt keinen Compiler"],
      ex:"Bytecode lÃ¤uft auf jeder Plattform mit JVM."}
  ];
  for (let i=0;i<n;i++){
    const b = base[i % base.length];
    const {options, correctIndex} = mkSingleCorrectOptions(b.a, b.wrong);
    qs.push(mkQ({title:b.q, options, correctIndex, explain:b.ex}));
  }
  return qs;
}

/** Topic: Operators/precedence/arithmetic results */
function genArithmetic(n) {
  const qs = [];
  for (let i=0;i<n;i++){
    // generate expression of form a + b * c OR (a+b)*c
    const a = 1 + (i*3)%9;          // 1..9
    const b = 2 + (i*5)%8;          // 2..9
    const c = 2 + (i*7)%7;          // 2..8
    const withParens = (i % 2 === 1);
    const expr = withParens ? `(${a} + ${b}) * ${c}` : `${a} + ${b} * ${c}`;
    const correct = withParens ? (a+b)*c : (a + b*c);

    const wrong1 = withParens ? (a + b*c) : ((a+b)*c); // swapped precedence
    const wrong2 = correct + (i%3 ? 1 : -1);
    const wrong3 = correct + (i%4 ? 2 : -2);

    const title = "Was ist die Ausgabe?";
    const code = `int x = ${expr};\nSystem.out.println(x);`;
    const {options, correctIndex} = mkSingleCorrectOptions(String(correct), [String(wrong1), String(wrong2), String(wrong3)]);
    qs.push(mkQ({title, code, options, correctIndex, explain:`PrÃ¤zedenz: * vor +. Klammern steuern die Reihenfolge. Ergebnis: ${correct}.`}));
  }
  return qs;
}

/** Topic: Increment/compound assignment */
function genIncrement(n) {
  const qs = [];
  for (let i=0;i<n;i++){
    const x = 1 + (i%9);
    const kind = i % 3;
    if (kind === 0) {
      const correct = x+1;
      const code = `int x = ${x};\nSystem.out.println(++x);`;
      const {options, correctIndex} = mkSingleCorrectOptions(String(correct), [String(x), String(x+2), "Compilerfehler"]);
      qs.push(mkQ({title:"Welche Ausgabe entsteht?", code, options, correctIndex, explain:"++x erhÃ¶ht zuerst, dann wird der neue Wert ausgegeben."}));
    } else if (kind === 1) {
      const correct = x;
      const code = `int x = ${x};\nSystem.out.println(x++);`;
      const {options, correctIndex} = mkSingleCorrectOptions(String(correct), [String(x+1), String(x-1), "Compilerfehler"]);
      qs.push(mkQ({title:"Welche Ausgabe entsteht?", code, options, correctIndex, explain:"x++ gibt zuerst den alten Wert aus, erhÃ¶ht danach."}));
    } else {
      const add = 2 + (i%7);
      const correct = x + add;
      const code = `int x = ${x};\nx += ${add};\nSystem.out.println(x);`;
      const {options, correctIndex} = mkSingleCorrectOptions(String(correct), [String(x), String(x*add), "Compilerfehler"]);
      qs.push(mkQ({title:"Welche Ausgabe entsteht?", code, options, correctIndex, explain:"x += n ist Ã¤quivalent zu x = x + n."}));
    }
  }
  return qs;
}

/** Topic: if without braces / control flow */
function genIf(n) {
  const qs = [];
  for (let i=0;i<n;i++){
    const x = (i%2===0) ? 10 : 0;
    const cond = (i%3===0) ? "x < 5" : "x > 5";
    const condTrue = eval(`${x} ${cond.replace("x","")}`); // safe: only > or <
    const code =
`int x = ${x};

if (${cond})
    System.out.print("A");
System.out.print("B");`;
    const correct = (condTrue ? "AB" : "B");
    const {options, correctIndex} = mkSingleCorrectOptions(correct, ["A","BA","Keine Ausgabe"]);
    qs.push(mkQ({
      title:"Welche Ausgabe wird erzeugt?",
      code,
      options,
      correctIndex,
      explain:"Ohne {} gehÃ¶rt nur die nÃ¤chste Anweisung zur if. Die zweite Ausgabe kommt immer."
    }));
  }
  return qs;
}

/** Topic: Arrays 1D indexing + length + out of bounds */
function genArrays1D(n) {
  const qs = [];
  for (let i=0;i<n;i++){
    const a0 = 3 + (i%7);
    const a1 = 5 + (i%9);
    const ask = i % 3;

    if (ask === 0) {
      const code = `int[] a = {${a0}, ${a1}};\nSystem.out.println(a[1]);`;
      const {options, correctIndex} = mkSingleCorrectOptions(String(a1), [String(a0), "2", "Compilerfehler"]);
      qs.push(mkQ({title:"Was kommt raus?", code, options, correctIndex, explain:"Arrays sind 0-basiert: a[0]=erstes Element, a[1]=zweites Element."}));
    } else if (ask === 1) {
      const code = `int[] a = {${a0}, ${a1}};\nSystem.out.println(a.length);`;
      const {options, correctIndex} = mkSingleCorrectOptions("2", [String(a0), String(a1), "Compilerfehler"]);
      qs.push(mkQ({title:"Was kommt raus?", code, options, correctIndex, explain:"a.length ist die Anzahl Elemente im Array (hier 2)."}));
    } else {
      const code = `int[] a = {${a0}, ${a1}};\nSystem.out.println(a[2]);`;
      const {options, correctIndex} = mkSingleCorrectOptions("Exception", [String(a0), String(a1), "Compilerfehler"]);
      qs.push(mkQ({title:"Was passiert?", code, options, correctIndex, explain:"Index 2 ist auÃŸerhalb (gÃ¼ltig: 0..1) â†’ Laufzeit-Exception (IndexOutOfBounds)."}));
    }
  }
  return qs;
}

/** Topic: Arrays 2D / jagged / out of bounds */
function genArrays2D(n) {
  const qs = [];
  for (let i=0;i<n;i++){
    const rows = 2 + (i%4); // 2..5
    const kind = i % 3;

    if (kind === 0) {
      // jagged creation
      const code =
`int[][] arr = new int[3][];
arr[0] = new int[1];
arr[1] = new int[2];
arr[2] = new int[3];`;
      const {options, correctIndex} = mkSingleCorrectOptions("Asymmetrisches (jagged) Array", ["Symmetrisches Array","Compilerfehler","Exception"]);
      qs.push(mkQ({title:"Was wird erzeugt?", code, options, correctIndex, explain:"Unterschiedliche ZeilenlÃ¤ngen â†’ asymmetrisch (jagged)."}));
    } else if (kind === 1) {
      const code =
`int[][] m = new int[${rows}][3];
System.out.println(m.length);`;
      const {options, correctIndex} = mkSingleCorrectOptions(String(rows), ["3","0","Compilerfehler"]);
      qs.push(mkQ({title:"Was kommt raus?", code, options, correctIndex, explain:"m.length ist die Anzahl Zeilen (erste Dimension)."}));
    } else {
      const code =
`int[][] arr = new int[3][];
arr[3] = new int[1];`;
      const {options, correctIndex} = mkSingleCorrectOptions("Exception", ["OK","Compilerfehler","Asymmetrisches Array"]);
      qs.push(mkQ({title:"Was passiert?", code, options, correctIndex, explain:"arr hat LÃ¤nge 3 â†’ gÃ¼ltige Indizes 0..2. arr[3] â†’ IndexOutOfBounds-Exception."}));
    }
  }
  return qs;
}

/** Topic: Type system / literals / casting */
function genTypesAndCasting(n) {
  const qs = [];
  const primitives = [
    {q:'Welchen Datentyp hat "128"?', a:"String", wrong:["byte","short","int"], ex:'"..." ist ein String-Literal.'},
    {q:"Welchen Datentyp hat '7'?", a:"char", wrong:["String","int","boolean"], ex:"'7' ist ein Zeichenliteral â†’ char."},
    {q:"Welche Aussage ist korrekt?", a:"Integer ist Wrapper-Klasse fÃ¼r int", wrong:["int ist Wrapper-Klasse fÃ¼r Integer","String ist primitiv","double ist Klasse"], ex:"Wrapper: Integer fÃ¼r int."},
  ];
  for (let i=0;i<n;i++){
    if (i % 2 === 0) {
      const a = 1 + (i%9);
      const b = 0.5 + ((i%7) * 0.5); // 0.5..3.5
      const sum = a + b;
      const correct = Math.trunc(sum);
      const code =
`int a = ${a};
double b = ${b};
int c = (int)(a + b);
System.out.println(c);`;
      const {options, correctIndex} = mkSingleCorrectOptions(String(correct), [String(correct+1), String(sum), "Compilerfehler"]);
      qs.push(mkQ({title:"Welche Ausgabe ist korrekt?", code, options, correctIndex, explain:"(int) cast schneidet Nachkommastellen ab (kein Runden)."}));
    } else {
      const p = primitives[i % primitives.length];
      const {options, correctIndex} = mkSingleCorrectOptions(p.a, p.wrong);
      qs.push(mkQ({title:p.q, options, correctIndex, explain:p.ex}));
    }
  }
  return qs;
}

/** Topic: Boolean operators (& | ^ && ||) */
function genBooleanLogic(n) {
  const qs = [];
  const bools = [true,false];
  for (let i=0;i<n;i++){
    const a = bools[i % 2];
    const b = bools[(i+1) % 2];
    const c = bools[(i+2) % 2];
    const kind = i % 4;

    let expr, correct;
    if (kind === 0) { expr = `${a} | ${b}`; correct = (a | b); }
    else if (kind === 1) { expr = `${a} & ${b}`; correct = (a & b); }
    else if (kind === 2) { expr = `${a} ^ ${b}`; correct = (a ^ b); }
    else { expr = `${a} || (${b} & ${c})`; correct = (a || (b & c)); }

    const correctText = correct ? "true" : "false";
    const {options, correctIndex} = mkSingleCorrectOptions(correctText, [correct ? "false":"true", "Compilerfehler", "0"]);
    qs.push(mkQ({
      title:`Ergebnis (true/false): ${expr}`,
      options, correctIndex,
      explain:"Bei boolean: | & ^ sind erlaubt. && und || sind Kurzschluss-Operatoren; & und | werten beide Seiten aus."
    }));
  }
  return qs;
}

/** Topic: Ternary operator */
function genTernary(n) {
  const qs = [];
  for (let i=0;i<n;i++){
    const z = (i%3===0) ? 0 : (i%2===0 ? 5 : -4);
    const out = (z>0) ? "positiv" : (z<0 ? "negativ" : "null");
    const code =
`int zahl = ${z};
System.out.println(zahl > 0 ? "positiv" : zahl < 0 ? "negativ" : "null");`;
    const {options, correctIndex} = mkSingleCorrectOptions(out, ["positiv","negativ","null"].filter(x=>x!==out));
    qs.push(mkQ({title:"Welche Ausgabe entsteht?", code, options, correctIndex, explain:"Verschachtelter ternÃ¤rer Operator: >0, sonst <0, sonst null."}));
  }
  return qs;
}

/** Topic: Semiotik */
function genSemiotics(n) {
  const qs = [];
  const items = [
    {q:"In welche semiotische Kategorie fÃ¤llt die EinrÃ¼ckung des Quelltexts?", a:"Pragmatik", wrong:["Lexikalik","Syntax","Semantik"], ex:"EinrÃ¼ckung ist fÃ¼r Lesbarkeit/Kommunikation (Menschen) â†’ Pragmatik."},
    {q:"Zu welcher Kategorie gehÃ¶rt die Bedeutung eines Programms?", a:"Semantik", wrong:["Syntax","Lexikalik","Pragmatik"], ex:"Semantik = Bedeutung/Verhalten."},
    {q:"Zu welcher Kategorie gehÃ¶rt die Struktur/Grammatik eines Programms?", a:"Syntax", wrong:["Semantik","Pragmatik","Lexikalik"], ex:"Syntax = formale Regeln."},
    {q:"Zu welcher Kategorie gehÃ¶ren Tokens/SchlÃ¼sselwÃ¶rter (z.B. if, int)?", a:"Lexikalik", wrong:["Semantik","Syntax","Pragmatik"], ex:"Lexikalik = Tokenisierung, SchlÃ¼sselwÃ¶rter, Bezeichner."}
  ];
  for (let i=0;i<n;i++){
    const it = items[i % items.length];
    const {options, correctIndex} = mkSingleCorrectOptions(it.a, it.wrong);
    qs.push(mkQ({title:it.q, options, correctIndex, explain:it.ex}));
  }
  return qs;
}

/** Topic: Methods / return / overloading / getters-setters basics (MC style) */
function genMethodsOOP(n) {
  const qs = [];
  const base = [
    {q:"Wie viele return-Anweisungen darf eine Methode enthalten?", a:"Beliebig viele", wrong:["Genau eine","Keine","Genau zwei"], ex:"Mehrere returns sind erlaubt (z.B. in if/else)."},
    {q:"Welche Voraussetzung gilt fÃ¼r MethodenÃ¼berladung?", a:"Andere Parameterliste", wrong:["Nur anderer RÃ¼ckgabewert","Nur anderer Methodenname","Nur anderer Sichtbarkeitsmodifikator"], ex:"Overloading: gleicher Name, aber andere Parameterliste (Typ/Anzahl/Reihenfolge)."},
    {q:"Welche Sichtbarkeit erlaubt Zugriff nur innerhalb der Klasse?", a:"private", wrong:["public","protected","package-private"], ex:"private kapselt auf Klassenebene."},
    {q:"WofÃ¼r steht this typischerweise?", a:"Verweis auf aktuelles Objekt", wrong:["Verweis auf Oberklasse","Erzeugt neues Objekt","Beendet Methode"], ex:"this referenziert die aktuelle Instanz."},
    {q:"Welche Zeile erzeugt ein Objekt der Klasse Auto?", a:"Auto a = new Auto();", wrong:["Auto a;","new Auto;","Auto = new a();"], ex:"Objekterzeugung: new + Konstruktoraufruf."},
    {q:"Welche Aussage zu static ist korrekt?", a:"static gehÃ¶rt zur Klasse", wrong:["static gehÃ¶rt zur Instanz","static braucht immer ein Objekt","static verhindert Vererbung"], ex:"static ist klassenweit."},
    {q:"Welcher Getter ist korrekt fÃ¼r private int punkte;", a:"public int getPunkte(){ return punkte; }",
      wrong:["public void getPunkte(){ return punkte; }","public int getPunkte(int p){ return p; }","public int getPunkte(){ return this; }"],
      ex:"Getter: RÃ¼ckgabetyp passt, keine Parameter, return Feld."},
    {q:"Welcher Setter ist korrekt fÃ¼r private int punkte;", a:"public void setPunkte(int punkte){ this.punkte = punkte; }",
      wrong:["public int setPunkte(int punkte){ return this.punkte; }","public void setPunkte(){ this.punkte = punkte; }","public void setPunkte(int p){ punkte = this.p; }"],
      ex:"Setter: void, Parameter, Zuweisung this.feld = parameter."},
  ];
  for (let i=0;i<n;i++){
    const b = base[i % base.length];
    const {options, correctIndex} = mkSingleCorrectOptions(b.a, b.wrong);
    qs.push(mkQ({title:b.q, options, correctIndex, explain:b.ex}));
  }
  return qs;
}

/** Topic: JOptionPane parsing (MC) */
function genParsing(n) {
  const qs = [];
  const base = [
    {q:"Welche Methode konvertiert einen String in einen int?", a:"Integer.parseInt(s)", wrong:["Integer.toString(s)","Double.parseInt(s)","String.valueOf(int)"], ex:"Integer.parseInt(String) â†’ int."},
    {q:"Welche Methode konvertiert einen String in einen double?", a:"Double.parseDouble(s)", wrong:["Double.toDouble(s)","Integer.parseDouble(s)","Math.double(s)"], ex:"Double.parseDouble(String) â†’ double."},
    {q:"Was macht (int)(zahl1 + zahl2) bei Nachkommastellen?", a:"Schneidet Nachkommastellen ab", wrong:["Rundet automatisch","Erzeugt String","Compilerfehler"], ex:"(int) cast trunciert (kein Runden)."},
  ];
  for (let i=0;i<n;i++){
    const b = base[i % base.length];
    const {options, correctIndex} = mkSingleCorrectOptions(b.a, b.wrong);
    qs.push(mkQ({title:b.q, options, correctIndex, explain:b.ex}));
  }
  return qs;
}

/** ---------- Build 500-question catalog (strict topics) ---------- **/
function buildCatalog500() {
  const catalog = [];
  // Tuned counts sum to 500 exactly
  catalog.push(...genTools(40));
  catalog.push(...genArithmetic(120));
  catalog.push(...genIncrement(80));
  catalog.push(...genIf(60));
  catalog.push(...genArrays1D(60));
  catalog.push(...genArrays2D(40));
  catalog.push(...genTypesAndCasting(40));
  catalog.push(...genBooleanLogic(30));
  catalog.push(...genTernary(10));
  catalog.push(...genSemiotics(10));
  catalog.push(...genMethodsOOP(8));
  catalog.push(...genParsing(2));

  // Ensure exactly 500
  assert(catalog.length === 500, `Katalog hat ${catalog.length} Fragen statt 500.`);
  return catalog;
}

/** ---------- Validation (hard gate) ---------- **/
function validateCatalog(catalog) {
  const seenIds = new Set();
  catalog.forEach((q, idx) => {
    assert(typeof q.id === "number", `Frage ${idx}: id fehlt/ungÃ¼ltig.`);
    assert(!seenIds.has(q.id), `Doppelte id: ${q.id}`);
    seenIds.add(q.id);

    assert(typeof q.title === "string" && q.title.trim().length > 0, `Frage ${q.id}: title fehlt.`);
    assert(Array.isArray(q.options) && q.options.length === 4, `Frage ${q.id}: options muss LÃ¤nge 4 haben.`);
    assert(q.options.every(o => typeof o === "string"), `Frage ${q.id}: options mÃ¼ssen Strings sein.`);
    assert(uniq(q.options).length === 4, `Frage ${q.id}: options enthalten Duplikate.`);
    assert(Number.isInteger(q.correctIndex) && q.correctIndex >= 0 && q.correctIndex < 4, `Frage ${q.id}: correctIndex ungÃ¼ltig.`);
    assert(typeof q.explain === "string" && q.explain.trim().length > 0, `Frage ${q.id}: explain fehlt.`);
    // Optional sanity: forbid empty distractors
    assert(q.options.every(o => o.trim().length > 0), `Frage ${q.id}: leere Option.`);
  });
}

/** ---------- Quiz Engine ---------- **/
const QUIZ_SIZE = 12;
let CATALOG = [];
let quiz = [];
let idx = 0;
let score = 0;
let answered = false;
let wrongLog = [];

function buildNewQuiz(fromQuestions) {
  const base = fromQuestions ?? CATALOG;
  const picked = sampleUnique(base, Math.min(QUIZ_SIZE, base.length)).map(withShuffledOptions);
  return picked;
}

function reset(mode = "new") {
  if (mode === "wrong") {
    const wrongQuestions = wrongLog.map(w => w.original);
    const src = wrongQuestions.length ? wrongQuestions : CATALOG;
    quiz = buildNewQuiz(src);
  } else {
    quiz = buildNewQuiz(CATALOG);
  }

  idx = 0;
  score = 0;
  answered = false;
  wrongLog = [];

  el("score").textContent = score;
  el("qTotal").textContent = quiz.length;
  el("result").style.display = "none";
  el("quizCard").style.display = "block";
  render();
}

function render() {
  const q = quiz[idx];
  el("qIndex").textContent = idx + 1;
  el("bar").style.width = `${(idx / quiz.length) * 100}%`;

  el("qTitle").textContent = q.title;

  if (q.code) {
    el("qCode").style.display = "block";
    el("qCode").textContent = q.code;
  } else {
    el("qCode").style.display = "none";
    el("qCode").textContent = "";
  }

  const optionsDiv = el("options");
  optionsDiv.innerHTML = "";

  q.shuffledOptions.forEach((opt, i) => {
    const label = document.createElement("label");
    label.className = "opt";
    label.setAttribute("data-index", String(i));

    const radio = document.createElement("input");
    radio.type = "radio";
    radio.name = "answer";
    radio.value = String(i);
    radio.addEventListener("change", () => {
      if (!answered) el("checkBtn").disabled = false;
    });

    const span = document.createElement("span");
    span.textContent = opt;

    label.appendChild(radio);
    label.appendChild(span);
    optionsDiv.appendChild(label);
  });

  answered = false;
  el("checkBtn").disabled = true;
  el("nextBtn").disabled = true;
  el("feedback").style.display = "none";
  el("feedback").className = "feedback";
  el("fbTitle").textContent = "";
  el("fbText").textContent = "";
}

function getSelectedIndex() {
  const checked = document.querySelector('input[name="answer"]:checked');
  return checked ? Number(checked.value) : null;
}

function markOptions(correctIndex, selectedIndex) {
  const optionEls = document.querySelectorAll(".opt");
  optionEls.forEach((optEl) => {
    const i = Number(optEl.getAttribute("data-index"));
    optEl.classList.remove("correct", "wrong");
    if (i === correctIndex) optEl.classList.add("correct");
    if (selectedIndex !== null && i === selectedIndex && selectedIndex !== correctIndex) {
      optEl.classList.add("wrong");
    }
    const input = optEl.querySelector("input");
    if (input) input.disabled = true;
  });
}

function check() {
  if (answered) return;
  const q = quiz[idx];
  const sel = getSelectedIndex();
  if (sel === null) return;

  answered = true;
  const ok = sel === q.shuffledCorrectIndex;
  if (ok) score += 1;
  else {
    wrongLog.push({
      original: {
        id: q.id, title: q.title, code: q.code,
        options: q.options, correctIndex: q.correctIndex, explain: q.explain
      },
      n: idx + 1,
      your: q.shuffledOptions[sel],
      right: q.shuffledOptions[q.shuffledCorrectIndex],
      explain: q.explain
    });
  }

  el("score").textContent = score;
  markOptions(q.shuffledCorrectIndex, sel);

  el("feedback").style.display = "block";
  el("feedback").classList.add(ok ? "ok" : "no");
  el("fbTitle").textContent = ok ? "âœ… Richtig" : "âŒ Falsch";
  el("fbText").textContent = q.explain;

  el("nextBtn").disabled = false;
}

function next() {
  if (!answered) return;
  idx += 1;
  if (idx >= quiz.length) finish();
  else render();
}

function finish() {
  el("bar").style.width = "100%";
  el("quizCard").style.display = "none";
  el("result").style.display = "block";

  const total = quiz.length;
  const percent = Math.round((score / total) * 100);
  el("resultText").textContent =
    `Du hast ${score} von ${total} Punkten (${percent}%). Pool: ${CATALOG.length} Fragen â€¢ Pro Quiz: ${QUIZ_SIZE} (random)`;

  const review = el("review");
  review.innerHTML = "";

  if (wrongLog.length === 0) {
    const div = document.createElement("div");
    div.className = "item";
    div.innerHTML = `<strong>Stark.</strong> Keine falschen Antworten. NÃ¤chster Step: Tempo hoch oder Klausurmodus ergÃ¤nzen.`;
    review.appendChild(div);
    return;
  }

  wrongLog.forEach((w) => {
    const div = document.createElement("div");
    div.className = "item";
    const codeBlock = w.original.code ? `<pre>${escapeHtml(w.original.code)}</pre>` : "";
    div.innerHTML = `
      <strong>Frage ${w.n}:</strong> ${escapeHtml(w.original.title)}<br/>
      ${codeBlock}
      <div class="small"><b>Deine Antwort:</b> ${escapeHtml(w.your)}</div>
      <div class="small"><b>Richtig:</b> ${escapeHtml(w.right)}</div>
      <div class="small"><b>Warum:</b> ${escapeHtml(w.explain)}</div>
    `;
    review.appendChild(div);
  });
}

/** ---------- Wiring ---------- **/
el("checkBtn").addEventListener("click", check);
el("nextBtn").addEventListener("click", next);
el("restartBtn").addEventListener("click", () => reset("new"));
el("restartBtn2").addEventListener("click", () => reset("new"));
el("reviewOnlyWrongBtn").addEventListener("click", () => reset("wrong"));

/** ---------- Boot ---------- **/
(function boot(){
  try {
    CATALOG = buildCatalog500();
    validateCatalog(CATALOG);
    el("poolSize").textContent = String(CATALOG.length);
    reset("new");
  } catch (e) {
    // Hard fail: do NOT run quiz with broken catalog
    const box = el("fatal");
    box.style.display = "block";
    box.textContent = "ðŸš¨ Quiz-Start gestoppt: " + (e?.message || String(e));
    el("quizCard").style.display = "none";
  }
})();
</script>
</body>
</html>
